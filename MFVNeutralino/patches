Index: GeneratorInterface/Pythia8Interface/src/Pythia8Hadronizer.cc
===================================================================
RCS file: /local/reps/CMSSW/CMSSW/GeneratorInterface/Pythia8Interface/src/Pythia8Hadronizer.cc,v
retrieving revision 1.33
diff -u -r1.33 Pythia8Hadronizer.cc
--- GeneratorInterface/Pythia8Interface/src/Pythia8Hadronizer.cc	30 Mar 2012 18:54:20 -0000	1.33
+++ GeneratorInterface/Pythia8Interface/src/Pythia8Hadronizer.cc	21 Jun 2012 16:59:02 -0000
@@ -105,6 +105,9 @@
     //
     EmissionVetoHook* fEmissionVetoHook;
 
+    bool* offsetAlready;
+    bool offsetNeutralinoDecayProducts;
+    void offsetParticleAndDescendants(Pythia8::Event& e, int iparticle, double x, double y, double z);
 };
 
 
@@ -119,7 +122,9 @@
   fInitialState(PP),
   fReweightUserHook(0),
   fJetMatchingHook(0),
-  fEmissionVetoHook(0)
+  fEmissionVetoHook(0),
+  offsetAlready(0),
+  offsetNeutralinoDecayProducts(params.getUntrackedParameter<bool>("offsetNeutralinoDecayProducts", false))
 {
   randomEngine = &getEngineReference();
 
@@ -387,11 +392,56 @@
   runInfo().setInternalXSec(xsec);
 }
 
-
+void Pythia8Hadronizer::offsetParticleAndDescendants(Pythia8::Event& e, int iparticle, double x, double y, double z) {
+  Pythia8::Particle& p = e[iparticle]; 
+  //printf("offsetParticleAndDescendants: %i %i %f %f %f\n", iparticle, p.id(), x, y, z);
+  if (offsetAlready[iparticle])
+    return;
+  offsetAlready[iparticle] = true;
+  p.xProd(p.xProd() + x);
+  p.yProd(p.yProd() + y);
+  p.zProd(p.zProd() + z);
+  if (p.daughter1() == 0 && p.daughter2() == 0)
+    return;
+  else if (p.daughter1() == 0)
+    offsetParticleAndDescendants(e, p.daughter2(), x, y, z);
+  else if (p.daughter2() == 0)
+    offsetParticleAndDescendants(e, p.daughter1(), x, y, z);
+  else
+    for (int i = p.daughter1(), ie = p.daughter2(); i <= ie; ++i)
+      offsetParticleAndDescendants(e, i, x, y, z);
+}
+  
 bool Pythia8Hadronizer::generatePartonsAndHadronize()
 {
   if (!pythia->next()) return false;
 
+  if (offsetNeutralinoDecayProducts) {
+    ostringstream out;
+    //printf("JMT generatePartonsAndHadronize events\n");
+    offsetAlready = new bool[pythia->event.size()];
+    for (int i = 0, ie = pythia->event.size(); i < ie; ++i) {
+      Pythia8::Particle& p = pythia->event[i];
+      if (p.daughter1() <= 0 || p.daughter2() <= 0 || p.daughter2() < p.daughter1())
+	continue;
+      double dist = sqrt(pow(p.xDec() - p.xProd(), 2) + pow(p.yDec() - p.yProd(), 2) + pow(p.zDec() - p.zProd(), 2)); // mm
+      int ndau = p.daughter2() - p.daughter1() + 1;
+      double x1 = p.xDec(), y1 = p.yDec(), z1 = p.zDec();
+      //printf("%10i | %10i %10i | %7i %7i | %7i %7i | %.3f %.3f | %.3f %.3f | %.3f %.3f | %.4f \n", i, p.id(), p.status(), p.mother1(), p.mother2(), p.daughter1(), p.daughter2(), p.eta(), p.phi(), p.xProd(), p.yProd(), x1, y1, dist);
+      if (dist > 1e-3 && ndau > 1 && p.id() == 1000022) {
+	out << "Particle with id 1000022 has flight distance greater than 1 micron (eta = " << p.eta() << ", phi = " << p.phi() << ", decay_vtx = " << x1 << ", " << y1 << ", " << z1 << "), and more than one daughter. going to move all its descendants to that position.\n";
+	for (int j = p.daughter1(), je = p.daughter2(); j <= je; ++j) {
+	  memset(offsetAlready, 0, sizeof(bool)*pythia->event.size());
+	  offsetParticleAndDescendants(pythia->event, j, x1, y1, z1);
+	}
+      }
+    }
+    delete [] offsetAlready;
+    //printf("%s\n", out.str().c_str());
+    //printf("done\n");
+    edm::LogWarning("generatePartonsAndHadronize") << "JMT:\n" << out.str();
+  }
+
   event().reset(new HepMC::GenEvent);
   toHepMC.fill_next_event(*pythiaEvent, event().get());
 
