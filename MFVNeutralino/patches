Index: GeneratorInterface/Pythia8Interface/src/Pythia8Hadronizer.cc
===================================================================
RCS file: /local/reps/CMSSW/CMSSW/GeneratorInterface/Pythia8Interface/src/Pythia8Hadronizer.cc,v
retrieving revision 1.33
diff -u -r1.33 Pythia8Hadronizer.cc
--- GeneratorInterface/Pythia8Interface/src/Pythia8Hadronizer.cc	30 Mar 2012 18:54:20 -0000	1.33
+++ GeneratorInterface/Pythia8Interface/src/Pythia8Hadronizer.cc	9 Nov 2012 18:45:28 -0000
@@ -105,6 +105,10 @@
     //
     EmissionVetoHook* fEmissionVetoHook;
 
+    bool* offsetAlready;
+    int offsetDecayParent;
+    std::vector<int> offsetDecayProducts;
+    void offsetParticleAndDescendants(Pythia8::Event& e, int iparticle, double x, double y, double z);
 };
 
 
@@ -119,8 +123,21 @@
   fInitialState(PP),
   fReweightUserHook(0),
   fJetMatchingHook(0),
-  fEmissionVetoHook(0)
-{
+  fEmissionVetoHook(0),
+  offsetAlready(0),
+  offsetDecayParent(0)
+{
+  if (params.existsAs<int>("offsetDecayParent")) {
+    offsetDecayParent = params.getParameter<int>("offsetDecayParent");
+    if (params.existsAs<std::vector<int> >("offsetDecayProducts")) {
+      for (const int& id : params.getParameter<std::vector<int> >("offsetDecayProducts"))
+	offsetDecayProducts.push_back(abs(id));
+      std::sort(offsetDecayProducts.begin(), offsetDecayProducts.end());
+    }
+    else
+      throw cms::Exception("Pythia8Hadronizer") << "offsetDecayParent specified but not offsetDecayProducts";
+  }
+
   randomEngine = &getEngineReference();
 
   //Old code that used Pythia8 own random engine
@@ -387,11 +404,81 @@
   runInfo().setInternalXSec(xsec);
 }
 
-
+void Pythia8Hadronizer::offsetParticleAndDescendants(Pythia8::Event& e, int iparticle, double x, double y, double z) {
+  Pythia8::Particle& p = e[iparticle]; 
+  //printf("offsetParticleAndDescendants: %i %i %f %f %f\n", iparticle, p.id(), x, y, z);
+  if (offsetAlready[iparticle])
+    return;
+  offsetAlready[iparticle] = true;
+  p.xProd(p.xProd() + x);
+  p.yProd(p.yProd() + y);
+  p.zProd(p.zProd() + z);
+  if (p.daughter1() == 0 && p.daughter2() == 0)
+    return;
+  else if (p.daughter1() == 0)
+    offsetParticleAndDescendants(e, p.daughter2(), x, y, z);
+  else if (p.daughter2() == 0)
+    offsetParticleAndDescendants(e, p.daughter1(), x, y, z);
+  else
+    for (int i = p.daughter1(), ie = p.daughter2(); i <= ie; ++i)
+      offsetParticleAndDescendants(e, i, x, y, z);
+}
+  
 bool Pythia8Hadronizer::generatePartonsAndHadronize()
 {
   if (!pythia->next()) return false;
 
+  if (offsetDecayParent > 0) {
+    static const bool debug = false;
+    ostringstream out;
+    if (debug) printf("JMT generatePartonsAndHadronize events\n");
+    offsetAlready = new bool[pythia->event.size()];
+    for (int i = 0, ie = pythia->event.size(); i < ie; ++i) {
+      Pythia8::Particle& p = pythia->event[i];
+      if (p.daughter1() <= 0 || p.daughter2() <= 0 || p.daughter2() < p.daughter1())
+	continue;
+      double dist = sqrt(pow(p.xDec() - p.xProd(), 2) + pow(p.yDec() - p.yProd(), 2) + pow(p.zDec() - p.zProd(), 2)); // mm
+      int ndau = p.daughter2() - p.daughter1() + 1;
+      double x1 = p.xDec(), y1 = p.yDec(), z1 = p.zDec();
+      if (debug) printf("%10i | %10i %10i | %7i %7i | %7i %7i | %.3f %.3f | %.3f %.3f | %.3f %.3f | %.4f \n", i, p.id(), p.status(), p.mother1(), p.mother2(), p.daughter1(), p.daughter2(), p.eta(), p.phi(), p.xProd(), p.yProd(), x1, y1, dist);
+      if (dist > 1e-3 && ndau > 1 && p.id() == offsetDecayParent) {
+	bool displace = true;
+
+	// Check to make sure the daughters are the ones we want. This
+	// guards against moving around e.g. (gluino -> gluino +
+	// gluon) = ISR copies.
+	if (ndau != int(offsetDecayProducts.size()))
+	  displace = false;
+	else {
+	  std::vector<int> daus;
+	  for (int j = p.daughter1(), je = p.daughter2(); j <= je; ++j)
+	    daus.push_back(abs(pythia->event[j].id()));
+	  std::sort(daus.begin(), daus.end());
+	  if (!std::equal(daus.begin(), daus.end(), offsetDecayProducts.begin()))
+	    displace = false;
+	}
+
+	if (displace) {
+	  out << "Particle with id " << offsetDecayParent << " and daughters ( ";
+	  for (auto id : offsetDecayProducts)
+	    out << id << " ";
+	  out << ") has flight distance greater than 1 micron (eta = " << p.eta() << ", phi = " << p.phi() << ", decay_vtx = " << x1 << ", " << y1 << ", " << z1 << "), and more than one daughter. going to move all its descendants to that position.\n";
+	  for (int j = p.daughter1(), je = p.daughter2(); j <= je; ++j) {
+	    memset(offsetAlready, 0, sizeof(bool)*pythia->event.size());
+	    offsetParticleAndDescendants(pythia->event, j, x1, y1, z1);
+	  }
+	}
+      }
+    }
+
+    delete [] offsetAlready;
+    if (debug) {
+      printf("%s\n", out.str().c_str());
+      printf("done\n");
+    }
+    edm::LogWarning("generatePartonsAndHadronize") << "JMT:\n" << out.str();
+  }
+
   event().reset(new HepMC::GenEvent);
   toHepMC.fill_next_event(*pythiaEvent, event().get());
 
